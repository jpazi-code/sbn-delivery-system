import {
  resolveSxValue
} from "./chunk-YFEFL7CF.js";
import {
  ClickAwayListener,
  useSnackbar
} from "./chunk-EAE6TP4Y.js";
import {
  applySoftInversion,
  applySolidInversion
} from "./chunk-UR4LT6ZW.js";
import {
  useSlot
} from "./chunk-ZKE7ANBV.js";
import {
  styled_default,
  useThemeProps
} from "./chunk-VFMBLEQE.js";
import {
  _objectWithoutPropertiesLoose,
  capitalize,
  clsx_default,
  composeClasses,
  generateUtilityClass2 as generateUtilityClass,
  generateUtilityClasses2 as generateUtilityClasses
} from "./chunk-QKXMFTVG.js";
import {
  _extends,
  init_extends,
  keyframes,
  require_prop_types
} from "./chunk-44UVXFCC.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@mui/joy/Snackbar/Snackbar.js
init_extends();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/@mui/joy/Snackbar/snackbarClasses.js
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
var snackbarClasses = generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft", "colorPrimary", "colorDanger", "colorNeutral", "colorSuccess", "colorWarning", "endDecorator", "sizeSm", "sizeMd", "sizeLg", "startDecorator", "variantPlain", "variantOutlined", "variantSoft", "variantSolid"]);
var snackbarClasses_default = snackbarClasses;

// node_modules/@mui/joy/Snackbar/Snackbar.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _excluded = ["anchorOrigin", "animationDuration", "autoHideDuration", "color", "children", "className", "component", "disableWindowBlurListener", "endDecorator", "invertedColors", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "onUnmount", "open", "resumeHideDuration", "size", "slots", "slotProps", "startDecorator", "variant"];
var _ = (t) => t;
var _t;
var _t2;
var useUtilityClasses = (ownerState) => {
  const {
    variant,
    color,
    size,
    anchorOrigin
  } = ownerState;
  const slots = {
    root: ["root", size && `size${capitalize(size)}`, color && `color${capitalize(color)}`, variant && `variant${capitalize(variant)}`, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`],
    startDecorator: ["startDecorator"],
    endDecorator: ["endDecorator"]
  };
  return composeClasses(slots, getSnackbarUtilityClass, {});
};
var enterAnimation = keyframes(_t || (_t = _`
  0% {
    transform: translateX(var(--Snackbar-translateX, 0px)) translateY(calc(var(--_Snackbar-anchorBottom, 1) * 100%));
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateX(var(--Snackbar-translateX, 0px)) translateY(0);
  }
`));
var exitAnimation = keyframes(_t2 || (_t2 = _`
  0% {
    transform: translateX(var(--Snackbar-translateX, 0px)) translateY(0);
    opacity: 1;
  }
  100% {
    transform: translateX(var(--Snackbar-translateX, 0px)) translateY(calc(var(--_Snackbar-anchorBottom, 1) * 100%));
    opacity: 0;
  }
`));
var SnackbarRoot = styled_default("div", {
  name: "JoySnackbar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme,
  ownerState
}) => {
  var _ownerState$anchorOri, _ownerState$anchorOri2, _ownerState$anchorOri3, _ownerState$anchorOri4, _ownerState$anchorOri5, _ownerState$anchorOri6, _theme$variants;
  const {
    p,
    padding,
    borderRadius
  } = resolveSxValue({
    theme,
    ownerState
  }, ["p", "padding", "borderRadius"]);
  return [_extends({
    "--Snackbar-radius": theme.vars.radius.sm,
    "--Snackbar-decoratorChildRadius": "max((var(--Snackbar-radius) - var(--variant-borderWidth, 0px)) - var(--Snackbar-padding), min(var(--Snackbar-padding) + var(--variant-borderWidth, 0px), var(--Snackbar-radius) / 2))",
    "--Button-minHeight": "var(--Snackbar-decoratorChildHeight)",
    "--IconButton-size": "var(--Snackbar-decoratorChildHeight)",
    "--Button-radius": "var(--Snackbar-decoratorChildRadius)",
    "--IconButton-radius": "var(--Snackbar-decoratorChildRadius)",
    "--Icon-color": "currentColor"
  }, ownerState.size === "sm" && {
    "--Snackbar-padding": "0.75rem",
    "--Snackbar-inset": "0.5rem",
    "--Snackbar-decoratorChildHeight": "1.5rem",
    "--Icon-fontSize": theme.vars.fontSize.xl,
    gap: "0.5rem"
  }, ownerState.size === "md" && {
    "--Snackbar-padding": "1rem",
    "--Snackbar-inset": "0.75rem",
    // the spacing between Snackbar and the viewport
    "--Snackbar-decoratorChildHeight": "2rem",
    "--Icon-fontSize": theme.vars.fontSize.xl,
    gap: "0.625rem"
  }, ownerState.size === "lg" && {
    "--Snackbar-padding": "1.25rem",
    "--Snackbar-inset": "1rem",
    "--Snackbar-decoratorChildHeight": "2.375rem",
    "--Icon-fontSize": theme.vars.fontSize.xl2,
    gap: "0.875rem"
  }, {
    zIndex: theme.vars.zIndex.snackbar,
    position: "fixed",
    display: "flex",
    alignItems: "center",
    minWidth: 300,
    top: ((_ownerState$anchorOri = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri.vertical) === "top" ? "var(--Snackbar-inset)" : void 0,
    left: ((_ownerState$anchorOri2 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri2.horizontal) === "left" ? "var(--Snackbar-inset)" : void 0,
    bottom: ((_ownerState$anchorOri3 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri3.vertical) === "bottom" ? "var(--Snackbar-inset)" : void 0,
    right: ((_ownerState$anchorOri4 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri4.horizontal) === "right" ? "var(--Snackbar-inset)" : void 0
  }, ((_ownerState$anchorOri5 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri5.horizontal) === "center" && {
    "--Snackbar-translateX": "-50%",
    left: "50%",
    transform: "translateX(var(--Snackbar-translateX))"
  }, ((_ownerState$anchorOri6 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri6.vertical) === "top" && {
    "--_Snackbar-anchorBottom": "-1"
  }, {
    animation: `${enterAnimation} ${ownerState.animationDuration}ms forwards`
  }, !ownerState.open && {
    animationName: exitAnimation
  }, {
    boxShadow: theme.vars.shadow.lg,
    backgroundColor: theme.vars.palette.background.surface,
    padding: `var(--Snackbar-padding)`,
    borderRadius: "var(--Snackbar-radius)"
  }, theme.typography[`body-${{
    sm: "xs",
    md: "sm",
    lg: "md"
  }[ownerState.size]}`], ownerState.variant === "solid" && ownerState.color && ownerState.invertedColors && applySolidInversion(ownerState.color)(theme), ownerState.variant === "soft" && ownerState.color && ownerState.invertedColors && applySoftInversion(ownerState.color)(theme), (_theme$variants = theme.variants[ownerState.variant]) == null ? void 0 : _theme$variants[ownerState.color]), p !== void 0 && {
    "--Snackbar-padding": p
  }, padding !== void 0 && {
    "--Snackbar-padding": padding
  }, borderRadius !== void 0 && {
    "--Snackbar-radius": borderRadius
  }];
});
var SnackbarStartDecorator = styled_default("span", {
  name: "JoySnackbar",
  slot: "StartDecorator",
  overridesResolver: (props, styles) => styles.startDecorator
})({
  display: "inherit",
  flex: "none"
});
var SnackbarEndDecorator = styled_default("span", {
  name: "JoySnackbar",
  slot: "EndDecorator",
  overridesResolver: (props, styles) => styles.endDecorator
})({
  display: "inherit",
  flex: "none",
  marginLeft: "auto"
});
var defaultAnchorOrigin = {
  vertical: "bottom",
  horizontal: "right"
};
var Snackbar = React.forwardRef(function Snackbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "JoySnackbar"
  });
  const {
    anchorOrigin = defaultAnchorOrigin,
    animationDuration = 300,
    autoHideDuration = null,
    color = "neutral",
    children,
    className,
    component,
    disableWindowBlurListener = false,
    endDecorator,
    invertedColors = false,
    onUnmount,
    open,
    size = "md",
    slots = {},
    slotProps,
    startDecorator,
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const [exited, setExited] = React.useState(true);
  const [exiting, setExiting] = React.useState(false);
  const unmountRef = React.useRef(onUnmount);
  unmountRef.current = onUnmount;
  React.useEffect(() => {
    if (open) {
      setExiting(false);
      setExited(false);
    } else {
      setExiting(true);
      const timer = setTimeout(() => {
        var _unmountRef$current;
        setExited(true);
        setExiting(false);
        (_unmountRef$current = unmountRef.current) == null || _unmountRef$current.call(unmountRef);
      }, animationDuration);
      return () => {
        clearTimeout(timer);
      };
    }
    return void 0;
  }, [open, animationDuration]);
  const ownerState = _extends({}, props, {
    anchorOrigin,
    autoHideDuration,
    color,
    animationDuration,
    disableWindowBlurListener,
    invertedColors,
    size,
    variant
  });
  delete ownerState.onUnmount;
  const classes = useUtilityClasses(ownerState);
  const {
    getRootProps,
    onClickAway
  } = useSnackbar(ownerState);
  const handleClickAway = (event) => {
    if (!exiting) {
      onClickAway(event);
    }
  };
  const externalForwardedProps = _extends({}, other, {
    component,
    slots,
    slotProps
  });
  const [SlotRoot, rootProps] = useSlot("root", {
    ref,
    className: clsx_default(classes.root, className),
    elementType: SnackbarRoot,
    externalForwardedProps,
    getSlotProps: getRootProps,
    ownerState
  });
  const [SlotStartDecorator, startDecoratorProps] = useSlot("startDecorator", {
    className: classes.startDecorator,
    elementType: SnackbarStartDecorator,
    externalForwardedProps,
    ownerState
  });
  const [SlotEndDecorator, endDecoratorProps] = useSlot("endDecorator", {
    className: classes.endDecorator,
    elementType: SnackbarEndDecorator,
    externalForwardedProps,
    ownerState
  });
  const SlotClickAway = slots.clickAway || ClickAwayListener;
  if (!open && exited) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(SlotClickAway, _extends({
    onClickAway: handleClickAway
  }, typeof (slotProps == null ? void 0 : slotProps.clickAway) === "function" ? slotProps.clickAway(ownerState) : slotProps == null ? void 0 : slotProps.clickAway, {
    children: (0, import_jsx_runtime2.jsxs)(SlotRoot, _extends({}, rootProps, {
      children: [startDecorator && (0, import_jsx_runtime.jsx)(SlotStartDecorator, _extends({}, startDecoratorProps, {
        children: startDecorator
      })), children, endDecorator && (0, import_jsx_runtime.jsx)(SlotEndDecorator, _extends({}, endDecoratorProps, {
        children: endDecorator
      }))]
    }))
  }));
});
true ? Snackbar.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The anchor of the `Snackbar`.
   * On smaller screens, the component grows to occupy all the available width,
   * the horizontal alignment is ignored.
   * @default { vertical: 'bottom', horizontal: 'right' }
   */
  anchorOrigin: import_prop_types.default.shape({
    horizontal: import_prop_types.default.oneOf(["center", "left", "right"]).isRequired,
    vertical: import_prop_types.default.oneOf(["bottom", "top"]).isRequired
  }),
  /**
   * The duration of the animation in milliseconds. This value is used to control
   * the length of time it takes for an animation to complete one cycle. It is also
   * utilized for delaying the unmount of the component.
   * Provide this value if you have your own animation so that we can precisely
   * time the component's unmount to match your custom animation.
   * @default 300
   */
  animationDuration: import_prop_types.default.number,
  /**
   * The number of milliseconds to wait before automatically calling the
   * `onClose` function. `onClose` should then set the state of the `open`
   * prop to hide the Snackbar. This behavior is disabled by default with
   * the `null` value.
   * @default null
   */
  autoHideDuration: import_prop_types.default.number,
  /**
   * @ignore
   */
  children: import_prop_types.default.node,
  /**
   * @ignore
   */
  className: import_prop_types.default.string,
  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   * @default 'neutral'
   */
  color: import_prop_types.default.oneOf(["danger", "neutral", "primary", "success", "warning"]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types.default.elementType,
  /**
   * If `true`, the `autoHideDuration` timer will expire even if the window is not focused.
   * @default false
   */
  disableWindowBlurListener: import_prop_types.default.bool,
  /**
   * Element placed after the children.
   */
  endDecorator: import_prop_types.default.node,
  /**
   * If `true`, the children with an implicit color prop invert their colors to match the component's variant and color.
   * @default false
   */
  invertedColors: import_prop_types.default.bool,
  /**
   * When displaying multiple consecutive snackbars using a single parent-rendered
   * `<Snackbar/>`, add the `key` prop to ensure independent treatment of each message.
   * For instance, use `<Snackbar key={message} />`. Otherwise, messages might update
   * in place, and features like `autoHideDuration` could be affected.
   */
  key: () => null,
  /**
   * @ignore
   */
  onBlur: import_prop_types.default.func,
  /**
   * Callback fired when the component requests to be closed.
   * Typically `onClose` is used to set state in the parent component,
   * which is used to control the `Snackbar` `open` prop.
   * The `reason` parameter can optionally be used to control the response to `onClose`,
   * for example ignoring `clickaway`.
   *
   * @param {React.SyntheticEvent<any> | Event} event The event source of the callback.
   * @param {string} reason Can be: `"timeout"` (`autoHideDuration` expired), `"clickaway"`, or `"escapeKeyDown"`.
   */
  onClose: import_prop_types.default.func,
  /**
   * @ignore
   */
  onFocus: import_prop_types.default.func,
  /**
   * @ignore
   */
  onMouseEnter: import_prop_types.default.func,
  /**
   * @ignore
   */
  onMouseLeave: import_prop_types.default.func,
  /**
   * A callback fired when the component is about to be unmounted.
   */
  onUnmount: import_prop_types.default.func,
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types.default.bool.isRequired,
  /**
   * The number of milliseconds to wait before dismissing after user interaction.
   * If `autoHideDuration` prop isn't specified, it does nothing.
   * If `autoHideDuration` prop is specified but `resumeHideDuration` isn't,
   * we default to `autoHideDuration / 2` ms.
   */
  resumeHideDuration: import_prop_types.default.number,
  /**
   * The size of the component.
   * @default 'md'
   */
  size: import_prop_types.default.oneOf(["sm", "md", "lg"]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: import_prop_types.default.shape({
    clickAway: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.shape({
      children: import_prop_types.default.element.isRequired,
      disableReactTree: import_prop_types.default.bool,
      mouseEvent: import_prop_types.default.oneOf(["onClick", "onMouseDown", "onMouseUp", "onPointerDown", "onPointerUp", false]),
      onClickAway: import_prop_types.default.func.isRequired,
      touchEvent: import_prop_types.default.oneOf(["onTouchEnd", "onTouchStart", false])
    })]),
    endDecorator: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
    root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
    startDecorator: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: import_prop_types.default.shape({
    clickAway: import_prop_types.default.elementType,
    endDecorator: import_prop_types.default.elementType,
    root: import_prop_types.default.elementType,
    startDecorator: import_prop_types.default.elementType
  }),
  /**
   * Element placed before the children.
   */
  startDecorator: import_prop_types.default.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
  /**
   * The [global variant](https://mui.com/joy-ui/main-features/global-variants/) to use.
   * @default 'outlined'
   */
  variant: import_prop_types.default.oneOf(["outlined", "plain", "soft", "solid"])
} : void 0;
var Snackbar_default = Snackbar;

export {
  getSnackbarUtilityClass,
  snackbarClasses_default,
  Snackbar_default
};
//# sourceMappingURL=chunk-Z7YZA4VC.js.map
